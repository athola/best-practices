<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Behavioral Patterns - Engineering Best Practices Guide</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Engineering Best Practices Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/your-org/best-practices" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="behavioral-design-patterns"><a class="header" href="#behavioral-design-patterns">Behavioral Design Patterns</a></h1>
<p>Behavioral design patterns are concerned with algorithms and the assignment of responsibilities between objects. They describe not just patterns of objects or classes but also the patterns of communication and interaction between them.</p>
<h2 id="chain-of-responsibility"><a class="header" href="#chain-of-responsibility">Chain of Responsibility</a></h2>
<p><strong>Intent</strong>: Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it.</p>
<p><strong>Key Insight</strong>: When you want to give multiple objects a chance to handle a request without knowing which object will handle it, the Chain of Responsibility pattern creates a pipeline of handlers. This is particularly useful for event handling systems, middleware pipelines, or any scenario where you want to decouple request senders from receivers.</p>
<p><strong>Consequences</strong>:</p>
<ul>
<li><strong>Pros</strong>: Reduces coupling between sender and receiver, simplifies object interconnections, allows for dynamic addition/removal of responsibilities, and promotes flexibility in assigning responsibilities.</li>
<li><strong>Cons</strong>: Can result in requests going unhandled, may introduce performance overhead due to chain traversal, and can make debugging difficult when requests fail to be handled.</li>
</ul>
<h2 id="command"><a class="header" href="#command">Command</a></h2>
<p><strong>Intent</strong>: Encapsulate a request as an object, thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations.</p>
<p><strong>Key Insight</strong>: When you need to decouple the object that invokes an operation from the one that knows how to perform it, the Command pattern encapsulates requests as objects. This is particularly useful for implementing undo/redo functionality, transactional systems, or when you want to queue, log, or parameterize requests.</p>
<p><strong>Consequences</strong>:</p>
<ul>
<li><strong>Pros</strong>: Decouples the object that invokes the operation from the one that knows how to perform it, supports undoable operations, allows for composition of commands into macro commands, and simplifies the addition of new commands.</li>
<li><strong>Cons</strong>: Can lead to an explosion of command classes, may introduce complexity for simple operations, and can make the system harder to understand due to the indirection.</li>
</ul>
<h2 id="interpreter"><a class="header" href="#interpreter">Interpreter</a></h2>
<p><strong>Intent</strong>: Given a language, define a representation for its grammar along with an interpreter that uses the representation to interpret sentences in the language.</p>
<p><strong>Key Insight</strong>: When you need to interpret a simple language or grammar, the Interpreter pattern defines a class hierarchy to represent the grammar rules. This is particularly useful for domain-specific languages, configuration files, or any scenario where you need to parse and evaluate expressions in a language.</p>
<p><strong>Consequences</strong>:</p>
<ul>
<li><strong>Pros</strong>: Easy to change and extend the grammar, easy to implement the grammar, and promotes code reuse for similar grammars.</li>
<li><strong>Cons</strong>: Can be complex for large grammars, may introduce performance overhead, and can be difficult to maintain as the grammar evolves.</li>
</ul>
<h2 id="iterator"><a class="header" href="#iterator">Iterator</a></h2>
<p><strong>Intent</strong>: Provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation.</p>
<p><strong>Key Insight</strong>: When you want to provide a uniform way to access different aggregate structures without exposing their internal structure, the Iterator pattern provides a standard interface for traversal. This is particularly useful for collections, trees, or any data structure where you want to separate traversal logic from the aggregate object.</p>
<p><strong>Consequences</strong>:</p>
<ul>
<li><strong>Pros</strong>: Supports variations in the traversal of an aggregate, simplifies the aggregate interface, and allows multiple traversals to be in progress simultaneously.</li>
<li><strong>Cons</strong>: Can introduce complexity for simple aggregates, may create additional objects, and can make the system harder to understand if overused.</li>
</ul>
<h2 id="mediator"><a class="header" href="#mediator">Mediator</a></h2>
<p><strong>Intent</strong>: Define an object that encapsulates how a set of objects interact. Mediator promotes loose coupling by keeping objects from referring to each other explicitly, and it lets you vary their interaction independently.</p>
<p><strong>Key Insight</strong>: When you have many objects that need to communicate with each other in complex ways, the Mediator pattern centralizes the communication logic. This is particularly useful for GUI systems, chat applications, or any scenario where you want to reduce the number of direct connections between objects.</p>
<p><strong>Consequences</strong>:</p>
<ul>
<li><strong>Pros</strong>: Reduces subclassing, decouples colleagues, simplifies object protocols, and abstracts how objects cooperate.</li>
<li><strong>Cons</strong>: Can become overly complex, may create a single point of failure, and can make the system harder to understand due to the centralization of logic.</li>
</ul>
<h2 id="memento"><a class="header" href="#memento">Memento</a></h2>
<p><strong>Intent</strong>: Without violating encapsulation, capture and externalize an object's internal state so that the object can be restored to this state later.</p>
<p><strong>Key Insight</strong>: When you need to implement undo/redo functionality or save and restore object state without breaking encapsulation, the Memento pattern provides a way to capture and restore state. This is particularly useful for text editors, games, or any application where you need to checkpoint and restore object state.</p>
<p><strong>Consequences</strong>:</p>
<ul>
<li><strong>Pros</strong>: Preserves encapsulation boundaries, simplifies the originator, and allows for easy implementation of undo/redo functionality.</li>
<li><strong>Cons</strong>: Can be expensive to store mementos, may introduce memory management issues, and can make the system more complex due to the additional classes.</li>
</ul>
<h2 id="observer"><a class="header" href="#observer">Observer</a></h2>
<p><strong>Intent</strong>: Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.</p>
<p><strong>Key Insight</strong>: When you need to maintain consistency between related objects without making them tightly coupled, the Observer pattern allows objects to subscribe to and receive notifications about state changes. This is particularly useful for event-driven systems, data binding, or any scenario where multiple objects need to react to changes in another object.</p>
<p><strong>Consequences</strong>:</p>
<ul>
<li><strong>Pros</strong>: Abstract coupling between subject and observer, supports broadcast communication, and allows for dynamic addition/removal of observers.</li>
<li><strong>Cons</strong>: Can lead to unexpected updates, may introduce debugging difficulties, and can create performance issues if not implemented carefully.</li>
</ul>
<h2 id="state"><a class="header" href="#state">State</a></h2>
<p><strong>Intent</strong>: Allow an object to alter its behavior when its internal state changes. The object will appear to change its class.</p>
<p><strong>Key Insight</strong>: When an object's behavior depends on its state and it must change its behavior at runtime depending on that state, the State pattern encapsulates state-specific behavior. This is particularly useful for state machines, workflow systems, or any object with complex state-dependent behavior.</p>
<p><strong>Consequences</strong>:</p>
<ul>
<li><strong>Pros</strong>: Localizes state-specific behavior, makes state transitions explicit, and allows state objects to be shared.</li>
<li><strong>Cons</strong>: Can increase the number of classes, may create complexity in state transitions, and can make the system harder to understand if the state logic is not well-designed.</li>
</ul>
<h2 id="strategy"><a class="header" href="#strategy">Strategy</a></h2>
<p><strong>Intent</strong>: Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it.</p>
<p><strong>Key Insight</strong>: When you have multiple ways to perform the same task and want to select the algorithm at runtime, the Strategy pattern encapsulates different algorithms. This is particularly useful for sorting algorithms, compression algorithms, or any scenario where you want to switch between different implementations of the same interface.</p>
<p><strong>Consequences</strong>:</p>
<ul>
<li><strong>Pros</strong>: Provides alternatives to subclassing, eliminates conditional statements, and allows for easy extension with new strategies.</li>
<li><strong>Cons</strong>: Can increase the number of objects, may create overhead for simple scenarios, and can make the system harder to understand if the strategy selection logic is complex.</li>
</ul>
<h2 id="template-method"><a class="header" href="#template-method">Template Method</a></h2>
<p><strong>Intent</strong>: Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm's structure.</p>
<p><strong>Key Insight</strong>: When you want to define the overall structure of an algorithm while allowing subclasses to provide specific implementations of certain steps, the Template Method pattern provides a framework. This is particularly useful for frameworks, libraries, or any scenario where you want to enforce a specific workflow while allowing customization.</p>
<p><strong>Consequences</strong>:</p>
<ul>
<li><strong>Pros</strong>: Maximizes code reuse, provides a clear algorithm structure, and allows for easy extension of specific steps.</li>
<li><strong>Cons</strong>: Can limit flexibility, may create complexity in the inheritance hierarchy, and can make the system harder to understand if the template method is not well-designed.</li>
</ul>
<h2 id="visitor"><a class="header" href="#visitor">Visitor</a></h2>
<p><strong>Intent</strong>: Represent an operation to be performed on the elements of an object structure. Visitor lets you define a new operation without changing the classes of the elements on which it operates.</p>
<p><strong>Key Insight</strong>: When you need to perform operations on a complex object structure without modifying the element classes, the Visitor pattern separates the operation from the structure. This is particularly useful for compilers, document processing, or any scenario where you want to add new operations to an existing class hierarchy without changing it.</p>
<p><strong>Consequences</strong>:</p>
<ul>
<li><strong>Pros</strong>: Makes adding new operations easy, gathers related operations together, and can traverse multiple object structures.</li>
<li><strong>Cons</strong>: Makes adding new element classes difficult, can break encapsulation, and may create complexity in the visitor hierarchy.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="design-patterns-structural.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="data-engineering.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="design-patterns-structural.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="data-engineering.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
